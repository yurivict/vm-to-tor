#!/bin/sh 

# Copyright (C) 2015 by Yuri Victorovich. All rights reserved.

# PROVIDE: vbox_to_tor
# REQUIRE: LOGIN ipfw
# KEYWORD: shutdown
# BEFORE: tor

# Add the following lines to /etc/rc.conf to enable vbox_to_tor:
# vbox_to_tor_enable (bool):	Set to "YES" to enable dhcp. Default: "NO"
# vbox_to_tor_ifaces (list):	Set it to the list of interfaces. Default: "tap0"
#                                 At least one interface is required.
# vbox_to_tor_net_pattern (str):Set it to the network pattern. Default: "172.16"
# vbox_to_tor_rule_base (uint):	Set it to the the rule number block location. Default: "3000"
# vbox_to_tor_extra_ports (list):	Set it to the the list of ports to open from host to VMs. Default: ""
# vbox_to_tor_control_socket (bool):	Set it to "YES" to allow host administration using ControlSocket. Default: "NO"
# vbox_to_tor_allow_cookie_auth (bool):	Set it to "YES" to allow cookie administration on ControlSocket. Default: "NO"
# vbox_to_tor_use_base (bool):	Set it to "YES" to use central tor daemon on host. Default: "NO"
#                                 By default individual tor instance is launched per interface.
#                                 Choosing "YES" requires less resources, but is marginally less secure.
#                                 It requires tor service to run, but it should start after vbox-to-tor.
# vbox_to_tor_hs (str):		Set it to the list of hidden services to route to VMs. Default: ""
#                                 List is 'newline' or '|' separarated.
#                                 Every element represents the hidden service in the format:
#                                   tapN /dir/to/hs/ oport iport
#

. /etc/rc.subr

name=vbox_to_tor
rcvar=vbox_to_tor_enable
start_cmd="vbox_to_tor_start"
stop_cmd="vbox_to_tor_stop"
status_cmd="vbox_to_tor_status"

# signature that will be placed into torrc to later be able to find our lines
torrc_signature="VBoxToTOR"
# where all tors data dirs are
tor_dir=/var/tmp/vbox-to-tor
tor_conf=/usr/local/etc/tor/torrc
# consts
NL=$'\n'
TAB=$'\t'

load_rc_config ${name}

: ${vbox_to_tor_enable="NO"}
: ${vbox_to_tor_ifaces="tap0"}
: ${vbox_to_tor_net_pattern="172.16"}
: ${vbox_to_tor_rule_base="3000"}
: ${vbox_to_tor_extra_ports=""}
: ${vbox_to_tor_control_socket="NO"}
: ${vbox_to_tor_allow_cookie_auth="NO"}
: ${vbox_to_tor_use_base="NO"}
: ${vbox_to_tor_hs=""}

## internals

tm() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')]"
}

unique_port_set() {
  echo $vbox_to_tor_extra_ports $vbox_to_tor_hs_all_ports | tr " ${TAB}" '\n' | sort | uniq
}

unique_port_set_for_iface() {
  eval "echo \$vbox_to_tor_extra_ports \$vbox_to_tor_hs_${1}_iports | tr \" \${TAB}\" '\\n' | sort | uniq"
}

calc_rule_step() {
  local port
  local cnt=0
  for port in $(unique_port_set); do
    cnt=$((cnt+1))
  done
  # 7 base rules required per interface
  cnt=$((cnt+7))
  for step in 10 20 50 100 200 500 1000; do
    if [ $cnt -le $step ]; then
      echo ${step}
      return
    fi
  done
  echo "too many ports requested"
  exit 1
}

check_tor_config() {
  # check we can really write /usr/local/etc/tor/torrc
  local rnd=$(jot -r 1 1000000 10000000)
  (test -w /usr/local/etc/tor/torrc &&
   test -w /usr/local/etc/tor &&
   touch /usr/local/etc/tor/torrc.tmp.${rnd} &&
   rm -f /usr/local/etc/tor/torrc.tmp.${rnd}) > /dev/null 2>/dev/null
}

ensure_kmod_loaded() {
  if !(kldstat -v | grep $1 >/dev/null); then
    kldload $1
  fi
}

parse_hs() {
  # parse HS definitions, if any
  local IFS="${NL}|"
  for hs in ${vbox_to_tor_hs}; do
    if [ -z "${hs}" ]; then
      continue
    fi
    local fidx=0
    local fld iface dir oport iport
    IFS=" ${TAB}"
    for fld in ${hs}; do
      case $fidx in
        0)
          iface="${fld}"
          ;;
        1)
          dir="${fld}"
          ;;
        2)
          oport="${fld}"
          ;;
        3)
          iport="${fld}"
          ;;
        *)
          echo "${name}: Too many fields in the hidden service definition: ${hs}" >&2
          return 1
          ;;
      esac
      fidx=$((fidx+1))
    done
    if [ -z "${iface}" -o -z "${dir}" -o -z "${oport}" -o -z "${iport}" ]; then
      echo "${name}: Too few fields in the hidden service definition: ${hs}" >&2
      return 1
    fi
    # fill hs info into global vars
    eval "vbox_to_tor_hs_${iface}=\"\$vbox_to_tor_hs_${iface} ${dir} ${oport} ${iport}\""
    eval "vbox_to_tor_hs_all_iports=\"\$vbox_to_tor_hs_all_iports ${iport}\""
    eval "vbox_to_tor_hs_${iface}_iports=\"\$vbox_to_tor_hs_${iface}_iports ${iport}\""
  done
}

create_tap() {
  for iface in ${vbox_to_tor_ifaces}; do
    local vm_id=$(echo $iface | sed -e 's/[a-z]*//')
    if !(ifconfig $iface create && \
         ifconfig $iface up && \
         ifconfig $iface inet "${vbox_to_tor_net_pattern}.${vm_id}.1/24" && \
         chown root:vboxusers /dev/$iface && \
         chmod 0660 /dev/$iface) >/dev/null 2>/dev/null; then
      echo "Failed to create interface $iface" >&2
      destroy_tap_silent
      return 1
    fi
  done
}

destroy_tap() {
  for iface in ${vbox_to_tor_ifaces}; do
    if ! ifconfig $iface destroy >/dev/null 2>/dev/null; then
      echo "Failed to destroy interface $iface" >&2
      destroy_tap_silent
      return 1
    fi
  done
}

destroy_tap_silent() {
  for iface in ${vbox_to_tor_ifaces}; do
    ifconfig $iface destroy >/dev/null 2>/dev/null
  done
}

change_sysctl() {
  # sysctl vars: VBox process needs to be able to open tapN, and listen on DNS port 53
  sysctl net.link.tap.user_open=1 >/dev/null &&
  sysctl net.inet.ip.portrange.reservedhigh=52 >/dev/null
}

add_ipfw_rules() {
  local ifaces="$1"
  local net_pattern="$2"
  local cmd=$vbox_to_tor_rule_base
  local step=$(calc_rule_step)
  local port
  local fwcmd="/sbin/ipfw -q"

  for iface in $ifaces; do
    local vm_id=$(echo $iface | sed -e 's/[a-z]*//')
    local vm_net="${net_pattern}.${vm_id}.0/24"
    local vm_gw="${net_pattern}.${vm_id}.1"

    # TCP: sink all TCP from this net to Tor's TransPort
    ${fwcmd} add $((cmd+0)) fwd ${vm_gw},9030 tcp from $vm_net to any in via $iface keep-state

    # DNS: allow DNS to go to TOR DNS port
    ${fwcmd} add $((cmd+1)) allow udp from ${vm_net} to ${vm_gw} 53 via $iface keep-state

    # DHCP: sink DHCP to server on gateway (DHCP requests can have both zero and non-zero source addresses)
    ${fwcmd} add $((cmd+3)) fwd ${vm_gw} udp from 0.0.0.0 to 255.255.255.255 67 in via $iface
    ${fwcmd} add $((cmd+2)) fwd ${vm_gw} udp from ${vm_net} to 255.255.255.255 67 in via $iface
    ${fwcmd} add $((cmd+4)) allow udp from ${vm_gw} to any 68 out via $iface

    # SSH: allow host-to-VM SSH for local administration
    ${fwcmd} add $((cmd+5)) allow tcp from ${vm_gw} to ${vm_net} 22 out via $iface keep-state

    # HS: you can add any additional host-to-VM TCP ports for TOR hidden services, or other purposes
    local pidx=0
    for port in $(unique_port_set_for_iface $iface); do
      ${fwcmd} add $((cmd+6+pidx)) allow tcp from ${vm_gw} to ${vm_net} ${port} out via $iface keep-state
      pidx=$((pidx+1))
    done

    # DENY: no other communication is allowed on this interface
    ${fwcmd} add $((cmd+step-1)) deny all from any to any via $iface

    # report
    echo "Added ipfw rules for VM ${iface} on ${vm_net} to connect to TOR"
    # move on
    cmd=$((cmd+step))
  done
}

start_tor_instance() {
  local iface="$1"
  local dir="$2"
  local gw="$3"
  local cl="$4"
  # create dirs
  (mkdir -p "${dir}/data" && chown -R _tor:_tor "${dir}" && chmod -R 0700 "${dir}") ||
    ! echo "${name}: Failed to create ${dir}/data" || return 1
  # create blank torrc, because it isn't clear how to avoid using the default
  touch ${dir}/torrc && chown _tor:_tor ${dir}/torrc && chmod 0600 ${dir}/torrc
  # prepare command line arguments
  local cmd="/usr/local/bin/tor"
  cmd="${cmd} -f ${dir}/torrc"
  cmd="${cmd} --PidFile ${dir}/tor.pid"
  cmd="${cmd} --RunAsDaemon 1"
  cmd="${cmd} --DataDirectory ${dir}/data"
  cmd="${cmd} --+Log \"notice file ${dir}/tor.log\""
  cmd="${cmd} --DNSPort 53"
  cmd="${cmd} --DNSListenAddress ${gw}"
  cmd="${cmd} --TransPort 9030"
  cmd="${cmd} --TransListenAddress ${gw}"
  cmd="${cmd} --SocksPort 0"
  if [ "${vbox_to_tor_control_socket}" = "YES" ]; then
    cmd="${cmd} --ControlSocket ${dir}/ctrl"
    cmd="${cmd} --CookieAuthentication 1"
  fi
  # enable hidden services resolution
  cmd="${cmd} --VirtualAddrNetworkIPv4 10.192.0.0/10"
  cmd="${cmd} --AutomapHostsOnResolve 1"
  # add hidden services that were requested
  local hidx=0
  local hs_fld hs_dir hs_oport hs_iport
  for hs_fld in $(eval "echo \$vbox_to_tor_hs_${iface}"); do
    case $hidx in
      0)
        hs_dir=${hs_fld}
        ;;
      1)
        hs_oport=${hs_fld}
        ;;
      2)
        hs_iport=${hs_fld}
        cmd="${cmd} --HiddenServiceDir ${hs_dir}"
        cmd="${cmd} --HiddenServicePort \"${hs_oport} ${cl}:${hs_iport}\""
        ;;
    esac
    [ $hidx -lt 2 ] && hidx=$((hidx+1)) || hidx=0
  done
  # log
  touch ${dir}/cmd.log && chown _tor:_tor ${dir}/cmd.log && chmod 0600 ${dir}/cmd.log
  echo "$(tm) ----- Running VM (tunnel $iface) -----" >> ${dir}/cmd.log
  echo "CMD: ${cmd}" >> ${dir}/cmd.log
  echo "$(tm) ----- BEGIN OUTPUT (tunnel $iface) -----" >> ${dir}/cmd.log
  # run it
  su -m _tor -c "umask 0077; ${cmd}" >> ${dir}/cmd.log 2>&1
  echo "$(tm) ----- END OUTPUT (tunnel $iface) -----" >> ${dir}/cmd.log
  # check if it is running
  [ -s ${dir}/tor.pid -a "$(procstat $(cat ${dir}/tor.pid) | tail -1 | sed -E 's/^[[:space:]]*([0-9]+).*/\1/g' 2>/dev/null)" = "$(cat ${dir}/tor.pid)" ]
}

start_tor_instances() {
  (rm -rf ${tor_dir}; mkdir -p "${tor_dir}" && chown _tor:_tor "${tor_dir}" && chmod 0700 "${tor_dir}") ||
    ! echo "${name}: Failed to create ${tor_dir}" || return 1
  for iface in ${vbox_to_tor_ifaces}; do
    local vm_id=$(echo $iface | sed -e 's/[a-z]*//')
    local vm_gw="${vbox_to_tor_net_pattern}.${vm_id}.1"
    local vm_cl="${vbox_to_tor_net_pattern}.${vm_id}.2"

    start_tor_instance "${iface}" "${tor_dir}/$iface" "${vm_gw}" "${vm_cl}" ||
      ! echo "${name}: Failed to start tor instance $iface" || stop_tor_instances_silent || return 1
  done
}

stop_tor_instances() {
  for iface in ${vbox_to_tor_ifaces}; do
    ([ -s ${tor_dir}/${iface}/tor.pid ] && kill $(cat ${tor_dir}/${iface}/tor.pid)) ||
       ! echo "${name}: failed to stop VM $iface" || stop_tor_instances_silent || return 1
    # XXX check the correctness of the above
  done
  rm -rf ${tor_dir}
}

stop_tor_instances_silent() {
  for iface in ${vbox_to_tor_ifaces}; do
    [ -s ${tor_dir}/${iface}/tor.pid ] && kill $(cat ${tor_dir}/${iface}/tor.pid) >/dev/null 2>/dev/null
  done
  # emergency stop, something went wrong, so keep logs
  return 0
}

warn_to_restart_tor_if_running() {
  if [ -r /var/run/tor/tor.pid ] && procstat $(cat /var/run/tor/tor.pid) > /dev/null 2>/dev/null; then
    echo "WARNING vbox-to-tor changed tor configuration, you need to restart tor: 'service tor restart'"
  fi
}

write_tor_config_section() {
  # The "right" way of doing this is through Tor control port.
  # However, this requires authentication, and we don't have
  # the password. vbox-to-tor is an automated process, and has
  # to always succeed. So we just overwrite that file in the
  # old fashion way. We add our signature to every line, so
  # that we can always delete these lines when we are stopped.
  # See torproject ticket#15649 with the request for this
  # functionality

  local conf_tmp_old="${tor_conf}.vbox-to-tor.old.tmp"
  local conf_tmp_new="${tor_conf}.vbox-to-tor.new.tmp"

  rm -f $conf_tmp_new $conf_tmp_old &&
  (cat $tor_conf &&
   echo "# [$torrc_signature] BEGIN vbox-to-tor section" &&
   (for iface in ${vbox_to_tor_ifaces}; do
      local vm_id=$(echo $iface | sed -e 's/[a-z]*//')
      echo "DNSListenAddress   172.16.${vm_id}.1    # $torrc_signature"
      echo "TransListenAddress 172.16.${vm_id}.1    # $torrc_signature"
    done) &&
   echo "# [$torrc_signature] END vbox-to-tor section") > $conf_tmp_new
  if [ $? = 0 -a -f $conf_tmp_new ]; then
    mv $tor_conf $conf_tmp_old &&
    mv $conf_tmp_new $tor_conf &&
    rm -f $conf_tmp_old
    warn_to_restart_tor_if_running
  else
    return 1
  fi
}

delete_tor_config_section() {
  local conf_tmp_old="${tor_conf}.vbox-to-tor.old.tmp"
  local conf_tmp_new="${tor_conf}.vbox-to-tor.new.tmp"

  rm -f $conf_tmp_new $conf_tmp_old &&
  (cat $tor_conf | grep -v $torrc_signature) > $conf_tmp_new
  if [ $? = 0 -a -f $conf_tmp_new ]; then
    mv $tor_conf $conf_tmp_old &&
    mv $conf_tmp_new $tor_conf &&
    rm -f $conf_tmp_old
    warn_to_restart_tor_if_running
  else
    return 1
  fi
}

delete_ipfw_rules() {
  local ifaces="$1"
  local cmd=$vbox_to_tor_rule_base
  local step=$(calc_rule_step)
  local fwcmd="/sbin/ipfw -q"
  for iface in $ifaces; do
    ${fwcmd} delete $(jot - $cmd $((cmd+step-1))) 2>/dev/null
    cmd=$((cmd+step))
  done
}

guess_process_name() {
  local proc_vbox=$(procstat -c $1 | tail -1 | grep "VirtualBox")
  if [ -n "${proc_vbox}" ]; then
    echo $(echo ${proc_vbox} | sed -E "s/.*--comment (([^ ]| [^-]| -[^-])*)( --.*|[[:space:]]*)$/\1/g")
  fi
}

count_tunnels() {
  local cnt=0
  local iface
  for iface in ${vbox_to_tor_ifaces}; do
    cnt=$((cnt+1))
  done
  echo $cnt
}

## interface for service manager

vbox_to_tor_start() {
  parse_hs || return 1
  check_tor_config &&
  ensure_kmod_loaded "if_tap" &&
  ensure_kmod_loaded "ipfw" &&
  create_tap &&
  add_ipfw_rules "${vbox_to_tor_ifaces}" "$vbox_to_tor_net_pattern" &&
  change_sysctl &&
  (
    ([ ${vbox_to_tor_use_base} = "YES" ] && write_tor_config_section) ||
    ([ ${vbox_to_tor_use_base} = "NO" ] && start_tor_instances)
  )
}

vbox_to_tor_status() {
  parse_hs || return 1
  local cntOk=0
  local cntNo=0
  local msgOk msgNo strOpened
  local ntunnels=$(count_tunnels)
  if [ $ntunnels -gt 1 ]; then
    local xnl="${NL}"
    local xbu=" * "
    local xlt=": "
    local xrt=""
  else
    local xnl=" "
    local xbu=""
    local xlt="("
    local xrt=")"
  fi
  for iface in ${vbox_to_tor_ifaces}; do
    if ! (ls /dev/ | grep $iface >/dev/null 2>/dev/null); then
      cntNo=$((cntNo+1))
      if [ $cntNo -gt 1 ]; then
        msgNo="${msgNo}"
      fi
      msgNo="${msgNo}${iface}"
    else
      cntOk=$((cntOk+1))
      local descr=""
      # vm pid
      strOpenedPid=$(ifconfig ${iface} | grep -i open | sed -e 's/[a-zA-Z[:space:]]*//g')
      if [ -n "${strOpenedPid}" ]; then
        descr="vm-pid=${strOpenedPid}"
        local processName=$(guess_process_name ${strOpenedPid})
        if [ -n "${processName}" ]; then
          descr="${descr} vm-name=${processName}"
        fi
      fi
      # tor pid
      if [ ${vbox_to_tor_use_base} = "NO" ]; then
        if [ -n "${descr}" ]; then
          descr="${descr} "
        fi
        descr="${descr}tor-pid=$(cat ${tor_dir}/${iface}/tor.pid)"
      fi
      # print iface status
      if [ $cntOk -gt 1 ]; then
        msgOk="${msgOk}${xnl}"
      fi
      if [ -n "${descr}" ]; then
        msgOk="${msgOk}${xbu}${iface}${xlt}${descr}${xrt}"
      else
        msgOk="${msgOk}${xbu}${iface}"
      fi
    fi
  done
  if [ $cntNo = 0 ]; then
    echo "$name is running with tunnels:${xnl}${msgOk}"
  elif [ $cntOk = 0 ]; then
    echo "$name is not running (${vbox_to_tor_ifaces})"
    return 1
  else
    echo "$name isn't properly setup: $cntNo of $((cntOk+cntNo)) tunnels doesn't exist (${vbox_to_tor_ifaces})"
    return 1
  fi
}

vbox_to_tor_stop() {
  parse_hs || return 1
  delete_ipfw_rules "${vbox_to_tor_ifaces}" &&
  destroy_tap &&
  (
    ([ ${vbox_to_tor_use_base} = "YES" ] && delete_tor_config_section) ||
    ([ ${vbox_to_tor_use_base} = "NO" ] && stop_tor_instances)
  )
}

command="/usr/bin/true"

run_rc_command "$1"
